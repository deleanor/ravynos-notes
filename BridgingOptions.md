More investigation reveals the following:

Bridging will require reimplementing the bridged Foundation classes to utilize CF functions internally, at least for allocation/initialization, but in most cases replacing the implementation entirely. Even once that is accomplished, the `_isa` pointers in `CFRuntimeBase` that mirror the objective c class memory layout have to be correctly wired up. This is done in `swift-corelibs-foundation/Foundation/NSSwiftRuntime.swift` via the `_CFRuntimeBridgeTypeToClass` function defined in `swift-corelibs-foundation/CoreFoundation/Base.subproj/CFRuntime.c`, but this is not part of the open source release for bridging objective-c classes. So as far as I can tell there are three options:

1. Bridge the appropriate classes in the current Foundation implementation. This will require reimplementing most of the implementations for the bridged classes listed [here](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html). This will also require porting the Swift code mentioned above to objective c in Foundation. PureDarwin has an incomplete version of this, but it looks like they either moved or completely removed the primary data structure used to set up the `CFTypeID` to `CFRuntimeBase->_isa` mapping and chose some other way to set up the C/ObjC correspondence.
2. Get Swift language support going and use Swift's Foundation implementation on top of the Swift runtime. I don't know what the implications would be for the existing objective c Frameworks that depend on Foundation. Also, the Swift build is complex and relies on a number of other Apple open source repositories, some of which may need to be decoupled from the language support or ported, so getting it integrated into the RavynOS build will be complicated and time consuming. This would almost certainly be a complete rework of the current Framework build structure and possibly large changes to all the other frameworks.
3. Defer bridging and try and get the Swift CF implementation in without it. Because of the original Framework implementation in which CF depends on Foundation, many implementations are just using the existing Foundation classes which depend minimally on CF. There are, however, places where this will be a problem in downstream frameworks, and those would be lurking issues that need to be found and handled on a case-by-case basis.

This may be stuff everyone already knows, but I'm catching up on how all of this is architected while I work through this, so I apologize if this is too much to write here, but I wasn't sure where else to put it. As always, I'm open to feedback on anything I'm misunderstanding or preferred directions based on project goals.
